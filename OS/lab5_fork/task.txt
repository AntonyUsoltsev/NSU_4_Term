Создание, завершение процесса
1. Жизненный цикл процесса.
    a. Напишите программу, которая:
        i. создает и инициализирует переменную (можно две: локальную и глобальную);
        ii. выводит ее (их) адрес(а) и содержимое;
        iii. выводит pid;
        iv. порождает новый процесс (используйте fork(2)).
        v. в дочернем процессе выводит pid и parent pid.
        vi. в дочернем процессе выводит адреса и содержимое переменных,
            созданных в пункте а;
        vii. в дочернем процессе изменяет содержимое переменных и
            выводит их значение;
        viii. в родительском процессе выводит содержимое переменных;
        ix. в родительском процессе делает sleep(30);
        x. в дочернем процессе завершается с кодом “5” (exit(2)).
        xi. в родительском процессе дожидается завершения дочернего,
            вычитывает код завершения и выводит причину завершения и код
            завершения если он есть. В каком случае кода завершения не
            будет?

            Код завершения не будет в случае, если процесс завершится некорректно, например, из-за сигнала,
            который не был обработан обработчиком сигнала.
            Также код завершения может быть недоступен, если процесс был убит другим процессом или системой.


    b. Объясните результаты работы программы.
    c. Понаблюдайте за адресными пространствами в procfs.
    d. Понаблюдайте за состояниями процесса в procfs или с помощью утилиты ps.

2. Процесс в состоянии зомби:
    a. Модифицируйте предыдущую программу так чтобы дочерний процесс
    становился зомби.
            Процесс-зомби,— дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке
            процессов операционной системы, чтобы дать родительскому процессу считать код завершения. Зомби-процесс
            существует до тех пор, пока родительский процесс не прочитает его статус с помощью системного вызова wait(),
            в результате чего запись в таблице процессов будет освобождена.

    b. Объясните какую проблему решает данное состояние.
    c. Может ли родительский процесс оказаться в состоянии зомби? Если да,
    то что в этом случае произойдет с дочерним? Смоделируйте эту ситуацию.
            Игнорирование обработки завершения дочерних процессов не является правильным, но обычно не приводит к проблемам
            для короткоживущих программ, так как при завершении процесса все его потомки становятся потомками процесса init,
            который постоянно считывает статус своих потомков-зомби, очищая таблицу процессов. Именно для задействования этого
            механизма выполняется стандартная техника запуска демонов "double fork()": промежуточный родитель завершается,
            делая родителем своего потомка процесс init .

3. Создание процесса при помощи системного вызова clone(2):
    a. Используйте системный вызов clone(2) для создания процесса:
        i. Память для стека выделите при помощи mmap(2), таким образом,
            чтобы новый регион был связан с файлом и синхронизировался с
            ним при изменении. Т.е. при записи в новый регион, данные
            должны синхронизироваться с файлом.
        ii. Напишите две функции:
            1. Первая - точка входа для нового процесса.
            2. Вторая функция должна выделять на стеке массив со
                строкой “hello world” и рекурсивно вызывать себя. Глубина
                рекурсии пусть будет равна 10.
        iii. Вызовите вторую функцию из функции нового процесса и после
            ее исполнения завершите новый процесс.
    b. Исследуйте полученный файл:
        i. найдите строки “hello world”. Сколько их и почему столько?
        ii. найдите переменную счетчик, которая используется для
        ограничения рекурсии.
        iii. найдите адреса возврата из функций.
